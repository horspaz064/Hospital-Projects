/**
 * DevExtreme (cjs/__internal/ui/toolbar/m_toolbar.js)
 * Version: 23.2.11
 * Build date: Mon Dec 16 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _component_registrator = _interopRequireDefault(require("../../../core/component_registrator"));
var _m_toolbar = _interopRequireDefault(require("./m_toolbar.base"));
var _m_toolbar2 = require("./m_toolbar.utils");
var _m_toolbar3 = require("./strategy/m_toolbar.multiline");
var _m_toolbar4 = require("./strategy/m_toolbar.singleline");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}

function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key]
                }
            }
        }
        return target
    };
    return _extends.apply(this, arguments)
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
const TOOLBAR_MULTILINE_CLASS = "dx-toolbar-multiline";
const TOOLBAR_AUTO_HIDE_TEXT_CLASS = "dx-toolbar-text-auto-hide";
let Toolbar = function(_ToolbarBase) {
    _inheritsLoose(Toolbar, _ToolbarBase);

    function Toolbar() {
        return _ToolbarBase.apply(this, arguments) || this
    }
    var _proto = Toolbar.prototype;
    _proto._getDefaultOptions = function() {
        return _extends(_extends({}, _ToolbarBase.prototype._getDefaultOptions.call(this)), {
            menuItemTemplate: "menuItem",
            menuContainer: void 0,
            overflowMenuVisible: false,
            multiline: false
        })
    };
    _proto._isMultiline = function() {
        return this.option("multiline")
    };
    _proto._dimensionChanged = function(dimension) {
        if ("height" === dimension) {
            return
        }
        _ToolbarBase.prototype._dimensionChanged.call(this);
        this._layoutStrategy._dimensionChanged()
    };
    _proto._initMarkup = function() {
        _ToolbarBase.prototype._initMarkup.call(this);
        this._updateFocusableItemsTabIndex();
        this._layoutStrategy._initMarkup()
    };
    _proto._renderToolbar = function() {
        _ToolbarBase.prototype._renderToolbar.call(this);
        this._renderLayoutStrategy()
    };
    _proto._itemContainer = function() {
        if (this._isMultiline()) {
            return this._$toolbarItemsContainer
        }
        return _ToolbarBase.prototype._itemContainer.call(this)
    };
    _proto._renderLayoutStrategy = function() {
        this.$element().toggleClass("dx-toolbar-multiline", this._isMultiline());
        this._layoutStrategy = this._isMultiline() ? new _m_toolbar3.MultiLineStrategy(this) : new _m_toolbar4.SingleLineStrategy(this)
    };
    _proto._renderSections = function() {
        if (this._isMultiline()) {
            return
        }
        return _ToolbarBase.prototype._renderSections.call(this)
    };
    _proto._postProcessRenderItems = function() {
        this._layoutStrategy._hideOverflowItems();
        this._layoutStrategy._updateMenuVisibility();
        _ToolbarBase.prototype._postProcessRenderItems.call(this);
        this._layoutStrategy._renderMenuItems()
    };
    _proto._renderItem = function(index, item, itemContainer, $after) {
        const itemElement = _ToolbarBase.prototype._renderItem.call(this, index, item, itemContainer, $after);
        this._layoutStrategy._renderItem(item, itemElement);
        const {
            widget: widget,
            showText: showText
        } = item;
        if ("dxButton" === widget && "inMenu" === showText) {
            itemElement.toggleClass("dx-toolbar-text-auto-hide")
        }
        return itemElement
    };
    _proto._getItemsWidth = function() {
        return this._layoutStrategy._getItemsWidth()
    };
    _proto._getMenuItems = function() {
        return this._layoutStrategy._getMenuItems()
    };
    _proto._getToolbarItems = function() {
        return this._layoutStrategy._getToolbarItems()
    };
    _proto._arrangeItems = function() {
        if (this.$element().is(":hidden")) {
            return
        }
        const elementWidth = this._layoutStrategy._arrangeItems();
        if (!this._isMultiline()) {
            _ToolbarBase.prototype._arrangeItems.call(this, elementWidth)
        }
    };
    _proto._itemOptionChanged = function(item, property, value, prevValue) {
        if (!this._isMenuItem(item)) {
            _ToolbarBase.prototype._itemOptionChanged.call(this, item, property, value, prevValue)
        }
        this._layoutStrategy._itemOptionChanged(item, property, value);
        if ("disabled" === property || "options.disabled" === property) {
            (0, _m_toolbar2.toggleItemFocusableElementTabIndex)(this, item)
        }
        if ("location" === property) {
            this.repaint()
        }
    };
    _proto._updateFocusableItemsTabIndex = function() {
        this._getToolbarItems().forEach(item => (0, _m_toolbar2.toggleItemFocusableElementTabIndex)(this, item))
    };
    _proto._isMenuItem = function(itemData) {
        return "menu" === itemData.location || "always" === itemData.locateInMenu
    };
    _proto._isToolbarItem = function(itemData) {
        return void 0 === itemData.location || "never" === itemData.locateInMenu
    };
    _proto._optionChanged = function(args) {
        const {
            name: name,
            value: value
        } = args;
        this._layoutStrategy._optionChanged(name, value);
        switch (name) {
            case "menuContainer":
            case "menuItemTemplate":
            case "overflowMenuVisible":
                break;
            case "multiline":
                this._invalidate();
                break;
            case "disabled":
                _ToolbarBase.prototype._optionChanged.call(this, args);
                this._updateFocusableItemsTabIndex();
                break;
            default:
                _ToolbarBase.prototype._optionChanged.call(this, args)
        }
    };
    _proto.updateDimensions = function() {
        this._dimensionChanged()
    };
    return Toolbar
}(_m_toolbar.default);
(0, _component_registrator.default)("dxToolbar", Toolbar);
var _default = Toolbar;
exports.default = _default;
