/**
 * DevExtreme (esm/__internal/ui/editor/m_editor.js)
 * Version: 23.2.11
 * Build date: Mon Dec 16 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    data
} from "../../../core/element_data";
import Guid from "../../../core/guid";
import $ from "../../../core/renderer";
import Callbacks from "../../../core/utils/callbacks";
import {
    noop
} from "../../../core/utils/common";
import {
    resetActiveElement
} from "../../../core/utils/dom";
import {
    extend
} from "../../../core/utils/extend";
import {
    hasWindow
} from "../../../core/utils/window";
import EventsEngine from "../../../events/core/events_engine";
import {
    addNamespace,
    normalizeKeyName
} from "../../../events/utils/index";
import ValidationEngine from "../../../ui/validation_engine";
import ValidationMessage from "../../../ui/validation_message";
import Widget from "../../../ui/widget/ui.widget";
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var READONLY_STATE_CLASS = "dx-state-readonly";
var INVALID_CLASS = "dx-invalid";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var VALIDATION_STATUS_VALID = "valid";
var VALIDATION_STATUS_INVALID = "invalid";
var READONLY_NAMESPACE = "editorReadOnly";
var ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
var VALIDATION_MESSAGE_KEYS_MAP = {
    validationMessageMode: "mode",
    validationMessagePosition: "positionSide",
    validationMessageOffset: "offset",
    validationBoundary: "boundary"
};
var Editor = Widget.inherit({
    ctor() {
        this.showValidationMessageTimeout = null;
        this.validationRequest = Callbacks();
        this.callBase.apply(this, arguments)
    },
    _createElement(element) {
        this.callBase(element);
        var $element = this.$element();
        if ($element) {
            data($element[0], VALIDATION_TARGET, this)
        }
    },
    _initOptions(options) {
        this.callBase.apply(this, arguments);
        this.option(ValidationEngine.initValidationOptions(options))
    },
    _init() {
        this._initialValue = this.option("value");
        this.callBase();
        this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
        var $element = this.$element();
        $element.addClass(DX_INVALID_BADGE_CLASS)
    },
    _getDefaultOptions() {
        return extend(this.callBase(), {
            value: null,
            name: "",
            onValueChanged: null,
            readOnly: false,
            isValid: true,
            validationError: null,
            validationErrors: null,
            validationStatus: VALIDATION_STATUS_VALID,
            validationMessageMode: "auto",
            validationMessagePosition: "bottom",
            validationBoundary: void 0,
            validationMessageOffset: {
                h: 0,
                v: 0
            },
            validationTooltipOptions: {},
            _showValidationMessage: true,
            isDirty: false
        })
    },
    _attachKeyboardEvents() {
        if (!this.option("readOnly")) {
            this.callBase()
        }
    },
    _setOptionsByReference() {
        this.callBase();
        extend(this._optionsByReference, {
            validationError: true
        })
    },
    _createValueChangeAction() {
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _suppressValueChangeAction() {
        this._valueChangeActionSuppressed = true
    },
    _resumeValueChangeAction() {
        this._valueChangeActionSuppressed = false
    },
    _initMarkup() {
        var _a;
        this._toggleReadOnlyState();
        this._setSubmitElementName(this.option("name"));
        this.callBase();
        this._renderValidationState();
        null === (_a = this.option("_onMarkupRendered")) || void 0 === _a ? void 0 : _a()
    },
    _raiseValueChangeAction(value, previousValue) {
        if (!this._valueChangeAction) {
            this._createValueChangeAction()
        }
        this._valueChangeAction(this._valueChangeArgs(value, previousValue))
    },
    _valueChangeArgs(value, previousValue) {
        return {
            value: value,
            previousValue: previousValue,
            event: this._valueChangeEventInstance
        }
    },
    _saveValueChangeEvent(e) {
        this._valueChangeEventInstance = e
    },
    _focusInHandler(e) {
        var _a;
        var isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
        if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
            var $validationMessageWrapper = null === (_a = this._validationMessage) || void 0 === _a ? void 0 : _a.$wrapper();
            null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO);
            clearTimeout(this.showValidationMessageTimeout);
            this.showValidationMessageTimeout = setTimeout(() => null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO), 150)
        }
        return this.callBase(e)
    },
    _canValueBeChangedByClick: () => false,
    _getStylingModePrefix: () => "dx-editor-",
    _renderStylingMode() {
        var optionValue = this.option("stylingMode");
        var prefix = this._getStylingModePrefix();
        var allowedStylingClasses = ALLOWED_STYLING_MODES.map(mode => prefix + mode);
        allowedStylingClasses.forEach(className => this.$element().removeClass(className));
        var stylingModeClass = prefix + optionValue;
        if (!allowedStylingClasses.includes(stylingModeClass)) {
            var defaultOptionValue = this._getDefaultOptions().stylingMode;
            var platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules()).stylingMode;
            stylingModeClass = prefix + (platformOptionValue || defaultOptionValue)
        }
        this.$element().addClass(stylingModeClass)
    },
    _getValidationErrors() {
        var validationErrors = this.option("validationErrors");
        if (!validationErrors && this.option("validationError")) {
            validationErrors = [this.option("validationError")]
        }
        return validationErrors
    },
    _disposeValidationMessage() {
        if (this._$validationMessage) {
            this._$validationMessage.remove();
            this.setAria("describedby", null);
            this._$validationMessage = void 0;
            this._validationMessage = void 0
        }
    },
    _toggleValidationClasses(isInvalid) {
        this.$element().toggleClass(INVALID_CLASS, isInvalid);
        this.setAria(VALIDATION_STATUS_INVALID, isInvalid || void 0)
    },
    _renderValidationState() {
        var isValid = this.option("isValid") && this.option("validationStatus") !== VALIDATION_STATUS_INVALID;
        var validationErrors = this._getValidationErrors();
        var $element = this.$element();
        this._toggleValidationClasses(!isValid);
        if (!hasWindow() || false === this.option("_showValidationMessage")) {
            return
        }
        this._disposeValidationMessage();
        if (!isValid && validationErrors) {
            var {
                validationMessageMode: validationMessageMode,
                validationMessageOffset: validationMessageOffset,
                validationBoundary: validationBoundary,
                rtlEnabled: rtlEnabled
            } = this.option();
            this._$validationMessage = $("<div>").appendTo($element);
            var validationMessageContentId = "dx-".concat(new Guid);
            this.setAria("describedby", validationMessageContentId);
            this._validationMessage = new ValidationMessage(this._$validationMessage, extend({
                validationErrors: validationErrors,
                rtlEnabled: rtlEnabled,
                target: this._getValidationMessageTarget(),
                visualContainer: $element,
                mode: validationMessageMode,
                positionSide: this._getValidationMessagePosition(),
                offset: validationMessageOffset,
                boundary: validationBoundary,
                contentId: validationMessageContentId
            }, this._options.cache("validationTooltipOptions")));
            this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions")
        }
    },
    _getValidationMessagePosition() {
        return this.option("validationMessagePosition")
    },
    _getValidationMessageTarget() {
        return this.$element()
    },
    _toggleReadOnlyState() {
        var readOnly = this.option("readOnly");
        this._toggleBackspaceHandler(readOnly);
        this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
        this.setAria("readonly", readOnly || void 0)
    },
    _toggleBackspaceHandler(isReadOnly) {
        var $eventTarget = this._keyboardEventBindingTarget();
        var eventName = addNamespace("keydown", READONLY_NAMESPACE);
        EventsEngine.off($eventTarget, eventName);
        if (isReadOnly) {
            EventsEngine.on($eventTarget, eventName, e => {
                if ("backspace" === normalizeKeyName(e)) {
                    e.preventDefault()
                }
            })
        }
    },
    _dispose() {
        var element = this.$element()[0];
        data(element, VALIDATION_TARGET, null);
        clearTimeout(this.showValidationMessageTimeout);
        this._disposeValidationMessage();
        this.callBase()
    },
    _setSubmitElementName(name) {
        var $submitElement = this._getSubmitElement();
        if (!$submitElement) {
            return
        }
        if (name.length > 0) {
            $submitElement.attr("name", name)
        } else {
            $submitElement.removeAttr("name")
        }
    },
    _getSubmitElement: () => null,
    _setValidationMessageOption(_ref) {
        var {
            name: name,
            value: value
        } = _ref;
        var _a;
        var optionKey = VALIDATION_MESSAGE_KEYS_MAP[name] ? VALIDATION_MESSAGE_KEYS_MAP[name] : name;
        null === (_a = this._validationMessage) || void 0 === _a ? void 0 : _a.option(optionKey, value)
    },
    _hasActiveElement: noop,
    _optionChanged(args) {
        var _a;
        switch (args.name) {
            case "onValueChanged":
                this._createValueChangeAction();
                break;
            case "readOnly":
                this._toggleReadOnlyState();
                this._refreshFocusState();
                break;
            case "value":
                if (args.value != args.previousValue) {
                    this.option("isDirty", this._initialValue !== args.value);
                    this.validationRequest.fire({
                        value: args.value,
                        editor: this
                    })
                }
                if (!this._valueChangeActionSuppressed) {
                    this._raiseValueChangeAction(args.value, args.previousValue);
                    this._saveValueChangeEvent(void 0)
                }
                break;
            case "width":
                this.callBase(args);
                null === (_a = this._validationMessage) || void 0 === _a ? void 0 : _a.updateMaxWidth();
                break;
            case "name":
                this._setSubmitElementName(args.value);
                break;
            case "isValid":
            case "validationError":
            case "validationErrors":
            case "validationStatus":
                this.option(ValidationEngine.synchronizeValidationOptions(args, this.option()));
                this._renderValidationState();
                break;
            case "validationBoundary":
            case "validationMessageMode":
            case "validationMessagePosition":
            case "validationMessageOffset":
                this._setValidationMessageOption(args);
                break;
            case "rtlEnabled":
                this._setValidationMessageOption(args);
                this.callBase(args);
                break;
            case "validationTooltipOptions":
                this._innerWidgetOptionChanged(this._validationMessage, args);
                break;
            case "_showValidationMessage":
            case "isDirty":
                break;
            default:
                this.callBase(args)
        }
    },
    _resetToInitialValue() {
        this.option("value", this._initialValue)
    },
    blur() {
        if (this._hasActiveElement()) {
            resetActiveElement()
        }
    },
    clear() {
        var defaultOptions = this._getDefaultOptions();
        this.option("value", defaultOptions.value)
    },
    reset() {
        var value = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
        if (arguments.length) {
            this._initialValue = value
        }
        this._resetToInitialValue();
        this.option("isDirty", false);
        this.option("isValid", true)
    }
});
Editor.isEditor = instance => instance instanceof Editor;
export default Editor;
